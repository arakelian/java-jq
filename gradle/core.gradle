// Generic helper .gradle file copied between projects
// Note: There is probably easier way to do this, maybe a Gradle plugin, but still learning Gradle.

task wrapper(type: Wrapper) {
    gradleVersion = '4.3.1'
}

if(project.plugins.hasPlugin("java")) {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
}

tasks.withType(JavaCompile) {
    // java 8 option which export names of constructor and method parameter names; no longer
    // have to declare parameter names with @JsonCreator
    options.compilerArgs << "-parameters"

    // Eclipse code formatting removes extraneous parenthesis which errorprone complains about
    if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
        options.compilerArgs << '-Xep:OperatorPrecedence:OFF'
    }
}

ext {
    // list of dependencies that we want to replace with Eclipse project refs;
    // we automatically add all Gradle projects that are sibling directories to this project.
    // NOTE: dependencies list here that end with a hyphen match modules that starting with that prefix.
    use_eclipse_project_refs = []

    // useful shortcuts
    buildAliases = [
        'all' : ['clean', 'classpath', 'build', 'install'],
        'deploy' : ['upload', 'closeAndReleaseRepository']
    ]
}

// Maven Central requires Javadocs

task javadocJar(type: Jar, dependsOn:classes) {
    classifier = 'javadoc'
    from javadoc
}

// always nice to have source code available in other projects

task sourcesJar(type:Jar, dependsOn:classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

// other projects may want to extend our unit tests

task testJar(type:Jar, dependsOn:testClasses) {
    classifier = 'tests'
    from sourceSets.test.output
}

artifacts {
    archives javadocJar
    archives sourcesJar
    archives testJar
}

repositories {
    // prefer locally built artifacts
    mavenLocal()

    // external maven repo is next preference
    mavenCentral()
    jcenter()
}

configurations {
    // mimic Maven 'provided' configuration, as suggested in GRADLE-784
    provided
    provided.extendsFrom(compile)

    // we use jcl-over-slf4j
    all*.exclude group: 'commons-logging'
}

sourceSets {
    main.compileClasspath += configurations.provided
    test.compileClasspath += configurations.provided
    test.runtimeClasspath += configurations.provided
}

idea {
    module {
        //if you need to put 'provided' dependencies on the classpath
        scopes.PROVIDED.plus += [ configurations.provided ]
    }
}

test {
    afterTest { desc, result ->
        // nice to see test results as they are executed
        println "${desc.className} > ${desc.name}  ${result.resultType}"
    }
}

// Custom Eclipse .classpath generation to use project references instead of .jar references; this
// allows us to do refactoring in Eclipse across projects
// see: https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseClasspath.html

eclipse {
    classpath {
        // override default 'bin'
        defaultOutputDir = file('target/classes')

        // ensure that 'provided' configuration jars available in Eclipose
        plusConfigurations += [ configurations.provided ]

        // we want source files
        downloadSources = true
        downloadJavadoc = false

        // customize generated .classpath file
        file {
            def project_refs = []
            def matched_libs = []

            // closure executed after .classpath content is loaded from existing file
            // and after gradle build information is merged
            whenMerged { classpath ->

                // build list of dependencies that we want to replace with Eclipse project refs
                println 'Finding local projects'
                def use_eclipse_project_refs = []
                new File("${projectDir}/..").eachDir {
                    if(new File("${it}/build.gradle").exists()) {
                        use_eclipse_project_refs += it.name
                     }
                }

                println 'Generating Eclipse .classpath file'
                def kindOrder = [ 'src':1, 'con':2, 'lib':3, 'output':0 ];
                classpath.entries.sort(true, { a,b ->
                    def order = kindOrder[a.kind] <=> kindOrder[b.kind]
                    order != 0 ? order : a.path <=> b.path
                } as Comparator).each { entry ->
                    if(entry.kind.equals('lib')) {
                        use_eclipse_project_refs.each { name ->
                            def regex = '/(' + ( name.endsWith('-') ?
                                java.util.regex.Pattern.quote(name.substring(0,name.length()-1)) + '(?:-[A-Za-z]+)*'
                                    : java.util.regex.Pattern.quote(name) ) + ')-([\\w\\.]+?)(-[A-Za-z]+)?\\.jar$'
                            def pattern = java.util.regex.Pattern.compile(regex)
                            def matcher = pattern.matcher(entry.path)
                            if(matcher.find()) {
                                def match = matcher.group(1)
                                println match + ' (' + matcher.group(2) + ') matched ' + entry.path
                                matched_libs += [ entry ]
                                project_refs += [ match ]
                            }
                        }
                    }
                }
                classpath.entries.removeAll(matched_libs)
            }

            // final adjustments to .classpath file before it is saved
            withXml { xml ->
                def node = xml.asNode()
                project_refs.unique(false).each { name ->
                    println "Creating Eclipse project dependency: " + name
                    node.appendNode('classpathentry', [ combineaccessrules: false, exported: true, kind: 'src', path: '/' + name ])
                }
            }
        }
    }
}

// convenience task to clean/generate Eclipse .classpath with short command
task classpath(dependsOn: ['cleanEclipseClasspath', 'eclipseClasspath', 'eclipseFactoryPath', 'cleanIdeaModule', 'ideaModule']) {
}

task generateGitProperties {
    doLast {
        def branch = 'git rev-parse --abbrev-ref HEAD'.execute().text.trim()
        def revision = 'git rev-list --max-count 1 --timestamp --abbrev-commit HEAD'.execute().text.trim()
        def commitHash = revision.split(' ').last()
        def timestamp = revision ? new java.util.Date(java.util.concurrent.TimeUnit.SECONDS.toMillis(revision.split(' ').first() as long)).format("yyyy-MM-dd'T'HH:mm:ssZ") : null

        File resourcesDir = new File(project.getBuildDir(), 'resources/main')
        File propertiesFile = new File(resourcesDir, 'git.properties')
        if(!propertiesFile.exists()) {
            resourcesDir.mkdirs()
            propertiesFile.createNewFile()
        }

        def newline = System.getProperty('line.separator')
        propertiesFile.text = "git.branch=${branch}${newline}" +
            "git.commit.id=${commitHash}${newline}" +
            "git.commit.time=${timestamp}${newline}" +
            "api.version=${project.version}${newline}"
    }
}

// this snippet is used for deployment to Maven Central

if (project.hasProperty('nexusUsername')) {
    signing {
        sign configurations.archives
    }

    // note: nexus credentials are typically kept in ~/.gradle/gradle.properties
    uploadArchives {
        repositories {
            // deploy locally
            mavenLocal()

            // see: http://central.sonatype.org/pages/gradle.html
            mavenDeployer {
                beforeDeployment {
                    MavenDeployment deployment -> signing.signPom(deployment)
                }

                repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
                    authentication(userName: nexusUsername, password: nexusPassword)
                }

                snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots/") {
                    authentication(userName: nexusUsername, password: nexusPassword)
                }

                pom.project {
                    name project.name
                    packaging 'jar'
                    description project.description

                    url 'https://github.com/arakelian/' + project.name
                    scm {
                        connection 'scm:git:https://github.com/arakelian/' + project.name + '.git'
                        developerConnection 'scm:git:git@github.com:arakelian/' + project.name + '.git'
                        url 'https://github.com/arakelian/' + project.name + '.git'
                    }

                    licenses {
                        license {
                            name 'Apache License 2.0'
                            url 'https://www.apache.org/licenses/LICENSE-2.0'
                            distribution 'repo'
                        }
                    }

                    developers {
                        developer {
                            id = 'arakelian'
                            name = 'Greg Arakelian'
                            email = 'greg@arakelian.com'
                        }
                    }
                }
            }
        }
    }
}

// replace version number in README file and commit the change;
// after this command, we're ready to tag the release

task updateReadme() {
    doLast {
        def nextVersion = project.version
        if(project.version.endsWith('-SNAPSHOT')) {
            // after committing the README file the project version will not have SNAPSHOT on it
            nextVersion = project.version.substring(0, project.version.length() -'-SNAPSHOT'.length())
        }

        def file = new File('README.md')
        def text = file.text
        println "Updating README to reference version " + nextVersion
        file.withWriter { w ->
          w << text.replaceAll("[0-9]+\\.[0-9]+\\.[0-9]+(-SNAPSHOT)?", nextVersion)
        }

        def uncommitted = 'git status README.md --porcelain'.execute().text.trim()
        if(uncommitted) {
            // commit change to README
            def cmd = ['git','commit','-m','Update README to version ' + nextVersion,'README.md']
            def process = new ProcessBuilder(cmd).redirectErrorStream(true).start()
            process.waitFor()
            println process.text
        } else {
            println "No changes made to README"
        }
    }
}

// when we tag a release use project version as tag comment

tag {
    message {
        "${project.version}"
    }
}

// This code allows us to define aliases, such as "all", so that when we do "gradle all",
// we can substitute in a series of other gradle tasks
// see: https://caffeineinduced.wordpress.com/2015/01/25/run-a-list-of-gradle-tasks-in-specific-order/

def expandedTaskList = []

// gradle respects ordering of tasks specified on command line, so we replace shortcuts
// with equivalent commands as though they were specified by user

gradle.startParameter.taskNames.each {
   expandedTaskList << (buildAliases[it] ? buildAliases[it] : it)
}

// replace command line arguments
gradle.startParameter.taskNames = expandedTaskList.flatten()
